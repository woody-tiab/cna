<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>인물백과 LIVE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/fonts-archive/Paperlogy/subsets/Paperlogy-dynamic-subset.css');
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Paperlogy', 'Noto Sans KR', sans-serif;
            background-color: #f1f5f9; /* slate-100 */
        }
        #chatbox::-webkit-scrollbar, #character-selection-list::-webkit-scrollbar, #character-description::-webkit-scrollbar {
            width: 8px;
        }
        #chatbox::-webkit-scrollbar-track, #character-selection-list::-webkit-scrollbar-track, #character-description::-webkit-scrollbar-track {
            background: transparent;
        }
        #chatbox::-webkit-scrollbar-thumb, #character-selection-list::-webkit-scrollbar-thumb, #character-description::-webkit-scrollbar-thumb {
            background: #cbd5e1; /* slate-300 */
            border-radius: 4px;
        }
        #chatbox::-webkit-scrollbar-thumb:hover, #character-selection-list::-webkit-scrollbar-thumb:hover, #character-description::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; /* slate-400 */
        }
        .message-bubble {
            max-width: 85%;
            word-wrap: break-word;
        }
        .message-bubble.user {
            background-color: #4f46e5; /* indigo-600 */
        }
        .message-bubble.bot {
            background-color: #ffffff;
            border: 1px solid #e2e8f0; /* slate-200 */
        }
        .dot-flashing {
            position: relative;
            width: 8px;
            height: 8px;
            border-radius: 5px;
            background-color: #64748b; /* slate-500 */
            color: #64748b;
            animation: dotFlashing 1s infinite linear alternate;
            animation-delay: .5s;
        }
        .dot-flashing::before, .dot-flashing::after {
            content: '';
            display: inline-block;
            position: absolute;
            top: 0;
        }
        .dot-flashing::before {
            left: -12px;
            width: 8px;
            height: 8px;
            border-radius: 5px;
            background-color: #64748b;
            color: #64748b;
            animation: dotFlashing 1s infinite alternate;
            animation-delay: 0s;
        }
        .dot-flashing::after {
            left: 12px;
            width: 8px;
            height: 8px;
            border-radius: 5px;
            background-color: #64748b;
            color: #64748b;
            animation: dotFlashing 1s infinite alternate;
            animation-delay: 1s;
        }
        @keyframes dotFlashing {
            0% { background-color: #64748b; }
            50%, 100% { background-color: #cbd5e1; }
        }
        .screen-bg {
            background-color: #f8fafc; /* slate-50 */
            background-image: radial-gradient(#e2e8f0 1px, transparent 1px);
            background-size: 1.5rem 1.5rem;
        }
    </style>
</head>
<body class="flex items-center justify-center h-screen p-4 bg-slate-100">

    <div class="w-full max-w-5xl h-full flex flex-col bg-white shadow-2xl rounded-2xl border border-slate-200">
        <!-- 초기 화면 -->
        <div id="initial-screen" class="flex flex-col items-center justify-center h-full p-8 text-center screen-bg rounded-2xl">
            <svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="text-indigo-500 mb-6 opacity-80"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
            <h1 class="text-3xl sm:text-4xl font-bold text-slate-900 mb-3 tracking-tight">인물백과 LIVE</h1>
            <p class="text-slate-600 text-base sm:text-lg mb-8">대화하고 싶은 인물의 이름을 입력하고 대화를 시작하세요.</p>
            <div class="w-full max-w-md">
                <input type="text" id="characterInput" class="w-full text-base px-4 py-3 border border-slate-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 mb-4" placeholder="예: 세종대왕, 이순신, 아인슈타인...">
                <button id="startButton" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">인물 검색</button>
            </div>
        </div>
        
        <!-- 인물 선택 화면 -->
        <div id="selection-screen" class="hidden flex flex-col items-center justify-center h-full p-4 sm:p-8 screen-bg rounded-2xl">
            <h2 class="text-3xl sm:text-4xl font-bold text-slate-900 mb-3 tracking-tight">대화할 인물을 선택해주세요</h2>
            <p class="text-slate-600 text-base sm:text-lg mb-8">입력하신 이름으로 여러 인물이 검색되었습니다.</p>
            <div id="character-selection-list" class="w-full max-w-3xl border border-slate-200 rounded-lg overflow-y-auto max-h-[50vh] sm:max-h-80 bg-white">
                <!-- 후보 리스트가 여기에 추가됩니다. -->
            </div>
             <button id="backButton" class="mt-8 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 text-base">뒤로가기</button>
        </div>

        <!-- 채팅 화면 -->
        <div id="chat-screen" class="hidden flex flex-col sm:flex-row h-full rounded-2xl overflow-hidden">
            <!-- 왼쪽 인물 정보 패널 -->
            <div class="w-full sm:w-1/3 p-6 flex flex-col items-center justify-start border-b sm:border-b-0 sm:border-r border-slate-200 screen-bg">
                <div class="w-full text-center pt-4 sm:pt-0">
                    <img id="character-image" src="" alt="초상화" class="hidden w-36 h-36 sm:w-48 sm:h-48 rounded-full object-cover border-4 border-white shadow-lg mb-5 bg-slate-200 mx-auto ring-4 ring-slate-200">
                    <h2 class="text-2xl sm:text-3xl font-bold text-slate-900 tracking-tight" id="character-name-display"></h2>
                    <a id="wikiLink" href="#" target="_blank" class="hidden mt-3 inline-flex items-center gap-2 bg-white hover:bg-slate-100 border border-slate-300 text-slate-700 font-semibold py-1 px-3 rounded-full text-xs transition-colors duration-200">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>
                        위키피디아 바로가기
                    </a>
                    <p id="character-description" class="text-base text-slate-600 mt-3 max-h-56 sm:max-h-72 overflow-y-auto leading-relaxed"></p>
                </div>
            </div>
            
            <!-- 오른쪽 채팅 패널 -->
            <div class="w-full sm:w-2/3 flex flex-col h-full bg-white">
                <!-- 헤더 -->
                <div class="flex items-center justify-between p-3 border-b border-slate-200 bg-white">
                    <p class="text-sm text-slate-500 pl-2">※ 본 대화는 AI가 생성한 가상 답변입니다.</p>
                    <button id="restartButton" class="bg-white hover:bg-slate-100 border border-slate-300 text-slate-700 font-semibold py-2 px-4 rounded-lg text-sm transition-colors duration-200">새 대화 시작</button>
                </div>
                
                <div id="chatbox" class="flex-1 p-4 sm:p-6 overflow-y-auto bg-slate-100"></div>

                <div class="p-4 border-t border-slate-200 bg-white/80 backdrop-blur-sm">
                    <div class="flex items-center space-x-3">
                        <input type="text" id="userInput" class="flex-1 w-full px-4 py-3 text-base border border-slate-300 rounded-full focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500" placeholder="질문을 입력하세요...">
                        <button id="sendButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-3 rounded-full shadow-md transition-all duration-200 transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-send"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const initialScreen = document.getElementById('initial-screen');
        const selectionScreen = document.getElementById('selection-screen');
        const chatScreen = document.getElementById('chat-screen');
        const characterInput = document.getElementById('characterInput');
        const startButton = document.getElementById('startButton');
        const backButton = document.getElementById('backButton');
        const characterSelectionList = document.getElementById('character-selection-list');
        const chatbox = document.getElementById('chatbox');
        const userInput = document.getElementById('userInput');
        const sendButton = document.getElementById('sendButton');
        const restartButton = document.getElementById('restartButton');
        const characterNameDisplay = document.getElementById('character-name-display');
        const characterImage = document.getElementById('character-image');
        const characterDescription = document.getElementById('character-description');
        const wikiLink = document.getElementById('wikiLink');

        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        
        const emojiPlaceholder = 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100%" height="100%" fill="%23e2e8f0"/><text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" font-size="60">😊</text></svg>';

        let chatHistory = [];
        let systemPrompt = "";
        let characterName = ""; // This will store the full original name for API calls

        const cleanName = (name) => {
            return name.split('(')[0].trim();
        };

        const cleanMarkdown = (text) => {
            if (!text) return '';
            // Removes markdown characters like *, **, #, etc.
            return text.replace(/([_*#`~])/g, '');
        };

        const fetchWithRetry = async (url, options, retries = 3, delay = 500) => {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return response;
                } catch (error) {
                    console.error(`Fetch attempt ${i + 1} for ${url} failed. Retrying in ${delay}ms...`, error);
                    if (i < retries - 1) {
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2; // Exponential backoff
                    } else {
                        throw error; // Rethrow the last error
                    }
                }
            }
        };


        window.addEventListener('load', async () => {
            const savedData = sessionStorage.getItem('chatData');
            if (savedData) {
                const { savedCharacterName, savedSystemPrompt, savedChatHistory } = JSON.parse(savedData);
                characterName = savedCharacterName;
                systemPrompt = savedSystemPrompt;
                chatHistory = savedChatHistory;
                
                initialScreen.classList.add('hidden');
                chatScreen.classList.remove('hidden');

                chatHistory.forEach(message => {
                    addMessageToChatbox(message.role === 'user' ? 'user' : 'bot', message.parts[0].text);
                });
                
                // Call fetchCharacterDetails but we don't need to await it here
                // because the system prompt is already saved.
                fetchCharacterDetails(characterName);
                
                autoScroll();
            }
        });

        const searchForCharacter = async () => {
            const query = characterInput.value.trim();
            if (!query) {
                alert('인물의 이름을 입력해주세요.');
                return;
            }
            
            const searchEndpoint = `https://ko.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(query)}&srlimit=5&srprop=snippet&format=json&origin=*`;
            try {
                const response = await fetchWithRetry(searchEndpoint);
                const data = await response.json();
                const searchResults = data.query.search;

                if (searchResults.length === 0) {
                    alert('해당 인물을 찾을 수 없습니다. 다른 이름으로 검색해보세요.');
                } else if (searchResults.length === 1 && cleanName(searchResults[0].title).toLowerCase() === query.toLowerCase()) {
                    initiateChat(searchResults[0].title);
                } else {
                    displayCharacterChoices(searchResults);
                }
            } catch (error) {
                console.error('Error searching Wikipedia:', error);
                alert('인물 검색 중 오류가 발생했습니다.');
            }
        };

        const displayCharacterChoices = (choices) => {
            characterSelectionList.innerHTML = '';
            initialScreen.classList.add('hidden');
            selectionScreen.classList.remove('hidden');

            choices.forEach(async choice => {
                const choiceElement = document.createElement('div');
                choiceElement.className = 'p-4 sm:p-5 hover:bg-slate-100 cursor-pointer border-b border-slate-200 last:border-b-0 text-left transition-colors duration-200 flex items-center gap-4';
                
                const img = document.createElement('img');
                img.className = 'w-16 h-16 rounded-full object-cover bg-slate-300 flex-shrink-0';
                
                img.src = emojiPlaceholder;
                img.alt = choice.title;
                img.onerror = () => { img.src = emojiPlaceholder; img.onerror = null; };

                const textWrapper = document.createElement('div');

                const title = document.createElement('h3');
                title.className = 'font-semibold text-base sm:text-lg text-slate-800';
                title.textContent = cleanName(choice.title);

                const description = document.createElement('p');
                description.className = 'text-sm text-slate-600 mt-1';
                
                let snippetText = choice.snippet.replace(/<[^>]*>/g, '').trim();
                const firstSentenceEnd = snippetText.indexOf('. ');
                if (firstSentenceEnd !== -1) {
                    const secondSentenceEnd = snippetText.indexOf('. ', firstSentenceEnd + 1);
                    if (secondSentenceEnd !== -1) {
                        snippetText = snippetText.substring(0, secondSentenceEnd + 1);
                    } else {
                        snippetText = snippetText.substring(0, firstSentenceEnd + 1);
                    }
                } else {
                    snippetText = snippetText.length > 120 ? snippetText.substring(0, 120) + '...' : snippetText;
                }
                description.textContent = snippetText;


                textWrapper.appendChild(title);
                textWrapper.appendChild(description);
                
                choiceElement.appendChild(img);
                choiceElement.appendChild(textWrapper);
                
                choiceElement.addEventListener('click', () => initiateChat(choice.title));
                characterSelectionList.appendChild(choiceElement);

                try {
                    const endpoint = `https://ko.wikipedia.org/w/api.php?action=query&format=json&prop=pageimages&pithumbsize=100&titles=${encodeURIComponent(choice.title)}&origin=*`;
                    const response = await fetchWithRetry(endpoint);
                    const data = await response.json();
                    const page = Object.values(data.query.pages)[0];
                    if (page.thumbnail) {
                        img.src = page.thumbnail.source;
                    }
                } catch (error) {
                    console.error(`Error fetching thumbnail for ${choice.title}:`, error);
                }
            });
        };

        const fetchCharacterDetails = async (originalName) => {
            const endpoint = `https://ko.wikipedia.org/w/api.php?action=query&format=json&prop=pageimages|extracts&pithumbsize=300&titles=${encodeURIComponent(originalName)}&exintro=true&explaintext=true&origin=*`;
            let pageExtract = '이 인물에 대한 간략한 소개를 찾을 수 없습니다.'; 

            try {
                characterNameDisplay.textContent = cleanName(originalName);
                characterDescription.textContent = '요약 정보를 생성 중입니다...';
                
                const wikiUrl = `https://ko.wikipedia.org/wiki/${encodeURIComponent(originalName)}`;
                wikiLink.href = wikiUrl;
                wikiLink.classList.remove('hidden');

                characterImage.src = emojiPlaceholder;
                characterImage.classList.remove('hidden');

                const response = await fetchWithRetry(endpoint);
                const data = await response.json();
                const page = Object.values(data.query.pages)[0];
                
                if (page.extract) {
                    pageExtract = page.extract;
                }

                if (page.thumbnail) {
                    characterImage.src = page.thumbnail.source;
                }

                try {
                    const summaryPrompt = `다음 텍스트를 학생이 이해하기 쉽도록 가장 중요한 내용 위주로 스크롤이 생기지 않을 정도의 간결한 한 문단으로 요약해줘. 절대로 마크다운 서식을 사용하지 마:\n\n${pageExtract}`;
                    const summaryPayload = { contents: [{ parts: [{ text: summaryPrompt }] }] };
                    
                    const summaryResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(summaryPayload)
                    });

                    if (summaryResponse.ok) {
                        const summaryResult = await summaryResponse.json();
                        if (summaryResult.candidates && summaryResult.candidates[0].content.parts[0].text) {
                             let summaryText = summaryResult.candidates[0].content.parts[0].text;
                             characterDescription.textContent = cleanMarkdown(summaryText);
                        }
                    } else {
                         const snippet = pageExtract.length > 150 ? pageExtract.substring(0, 150) + '...' : pageExtract;
                         characterDescription.textContent = snippet;
                    }
                } catch (summaryError) {
                     console.error('AI 요약 중 오류 발생, 일부 원문을 표시합니다:', summaryError);
                     const snippet = pageExtract.length > 150 ? pageExtract.substring(0, 150) + '...' : pageExtract;
                     characterDescription.textContent = snippet;
                }

                return pageExtract; // Return the full text for system prompt

            } catch (error) {
                console.error('인물 정보 로딩 중 오류 발생:', error);
                characterDescription.textContent = '정보를 불러오는 데 실패했습니다.';
                return pageExtract;
            } finally {
                characterImage.onerror = () => {
                    characterImage.src = emojiPlaceholder;
                    characterImage.onerror = null;
                };
            }
        };

        const setupSystemPromptAndDetails = async (originalName) => {
            const pageExtract = await fetchCharacterDetails(originalName);
            const currentDate = new Date().toLocaleDateString('ko-KR');

            systemPrompt = `현재 날짜는 ${currentDate}입니다. 당신의 정체성은 '${originalName}'입니다. 당신의 모든 답변은 아래 제공된 최신 위키피디아 정보를 가장 중요한 핵심 참고 자료로 사용해야 합니다. 이 정보에 없는 내용은 당신의 기존 지식을 활용하여 자연스럽게 답변하되, 위키피디아 내용과 충돌해서는 안 됩니다.

--- 제공된 위키피디아 정보 ---
${pageExtract}
--- 정보 끝 ---

사용자는 여러 동명이인 중에서 당신을 선택했으므로 다른 인물과 혼동하지 마세요. 당신의 생애, 업적, 가치관에 대해 1인칭 시점으로 답변해주세요. 학생이 이해하기 쉽도록 친절하게 설명하되, 역사적 사실에 기반해야 합니다. 답변은 항상 한국어로, 그리고 간결하게 2~3문장 내외로 답변해주세요. 절대로, 어떠한 경우에도 답변에 '**', '*', '#'와 같은 마크다운 서식을 사용해서는 안됩니다. 답변은 무조건 순수 텍스트(Plain Text)여야 합니다.`;

            saveToSession(); // Re-save with the full prompt
        };

        const initiateChat = (originalName) => {
            characterName = originalName; 
            selectionScreen.classList.add('hidden');
            initialScreen.classList.add('hidden');
            chatScreen.classList.remove('hidden');
            
            chatbox.innerHTML = ''; 
            
            const displayName = cleanName(originalName);
            const firstMessageText = `안녕하세요, 저는 ${displayName}입니다. 무엇이 궁금하신가요?`;
            const firstMessage = { role: 'model', parts: [{ text: firstMessageText }] };
            chatHistory = [firstMessage];
            
            addMessageToChatbox('bot', firstMessageText);
            
            // Set up details and the full system prompt in the background
            setupSystemPromptAndDetails(originalName);
            
            saveToSession(); // Save initial state
        };

        const sendMessage = async () => {
            const messageText = userInput.value.trim();
            if (!messageText) return;
            addMessageToChatbox('user', messageText);
            userInput.value = '';
            chatHistory.push({ role: 'user', parts: [{ text: messageText }] });
            saveToSession();
            addLoadingIndicator();
            try {
                const response = await getGeminiResponse();
                removeLoadingIndicator();
                let botMessageText = response.candidates[0].content.parts[0].text;
                botMessageText = cleanMarkdown(botMessageText); // Clean the response
                addMessageToChatbox('bot', botMessageText);
                chatHistory.push({ role: 'model', parts: [{ text: botMessageText }] });
                saveToSession();
            } catch (error) {
                console.error('API 호출 오류:', error);
                removeLoadingIndicator();
                addMessageToChatbox('bot', '죄송합니다. 답변을 생성하는 중에 문제가 발생했습니다.');
            }
        };
        
        const getGeminiResponse = async (retries = 3, delay = 1000) => {
             const payload = { contents: chatHistory, systemInstruction: { parts: [{ text: systemPrompt }] } };
             for (let i = 0; i< retries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error(`Attempt ${i + 1} failed. Retrying in ${delay}ms...`, error);
                    if (i < retries - 1) {
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2;
                    } else throw error;
                }
            }
        };

        const addMessageToChatbox = (sender, message) => {
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `flex mb-4 ${sender === 'user' ? 'justify-end' : 'justify-start'}`;
            const messageBubble = document.createElement('div');
            messageBubble.className = `message-bubble rounded-xl py-2 px-4 shadow-sm ${sender === 'user' ? 'user text-white' : 'bot text-slate-800'}`;
            messageBubble.textContent = message;
            messageWrapper.appendChild(messageBubble);
            chatbox.appendChild(messageWrapper);
            autoScroll();
        };
        
        const addLoadingIndicator = () => {
            const loadingWrapper = document.createElement('div');
            loadingWrapper.id = 'loading-indicator';
            loadingWrapper.className = 'flex justify-start mb-4';
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble bot rounded-xl p-4 shadow-sm flex items-center justify-center';
            const dots = document.createElement('div');
            dots.className = 'dot-flashing';
            bubble.appendChild(dots);
            loadingWrapper.appendChild(bubble);
            chatbox.appendChild(loadingWrapper);
            autoScroll();
        };

        const removeLoadingIndicator = () => {
            const indicator = document.getElementById('loading-indicator');
            if (indicator) indicator.remove();
        };
        
        const autoScroll = () => { chatbox.scrollTop = chatbox.scrollHeight; };
        
        const restartChat = () => {
            sessionStorage.removeItem('chatData');
            chatHistory = [];
            systemPrompt = "";
            characterName = "";
            chatbox.innerHTML = '';
            characterInput.value = '';
            characterImage.classList.add('hidden');
            characterImage.src = '';
            wikiLink.classList.add('hidden');
            selectionScreen.classList.add('hidden');
            chatScreen.classList.add('hidden');
            initialScreen.classList.remove('hidden');
        };

        const saveToSession = () => {
            const dataToSave = {
                savedCharacterName: characterName,
                savedSystemPrompt: systemPrompt,
                savedChatHistory: chatHistory
            };
            sessionStorage.setItem('chatData', JSON.stringify(dataToSave));
        };
        
        const goBackToInitial = () => {
            selectionScreen.classList.add('hidden');
            initialScreen.classList.remove('hidden');
        }

        startButton.addEventListener('click', searchForCharacter);
        sendButton.addEventListener('click', sendMessage);
        restartButton.addEventListener('click', restartChat);
        backButton.addEventListener('click', goBackToInitial);
        userInput.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); sendMessage(); } });
        characterInput.addEventListener('keydown', e => { if (e.key === 'Enter') searchForCharacter(); });
    </script>
</body>
</html>

