<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì¸ë¬¼ë°±ê³¼ LIVE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/fonts-archive/Paperlogy/subsets/Paperlogy-dynamic-subset.css');
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Paperlogy', 'Noto Sans KR', sans-serif;
            background-color: #f1f5f9; /* slate-100 */
        }
        #chatbox::-webkit-scrollbar, #character-selection-list::-webkit-scrollbar, #character-description::-webkit-scrollbar {
            width: 8px;
        }
        #chatbox::-webkit-scrollbar-track, #character-selection-list::-webkit-scrollbar-track, #character-description::-webkit-scrollbar-track {
            background: transparent;
        }
        #chatbox::-webkit-scrollbar-thumb, #character-selection-list::-webkit-scrollbar-thumb, #character-description::-webkit-scrollbar-thumb {
            background: #cbd5e1; /* slate-300 */
            border-radius: 4px;
        }
        #chatbox::-webkit-scrollbar-thumb:hover, #character-selection-list::-webkit-scrollbar-thumb:hover, #character-description::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; /* slate-400 */
        }
        .message-bubble {
            max-width: 85%;
            word-wrap: break-word;
        }
        .message-bubble.user {
            background-color: #4f46e5; /* indigo-600 */
        }
        .message-bubble.bot {
            background-color: #ffffff;
            border: 1px solid #e2e8f0; /* slate-200 */
        }
        .dot-flashing {
            position: relative;
            width: 8px;
            height: 8px;
            border-radius: 5px;
            background-color: #64748b; /* slate-500 */
            color: #64748b;
            animation: dotFlashing 1s infinite linear alternate;
            animation-delay: .5s;
        }
        .dot-flashing::before, .dot-flashing::after {
            content: '';
            display: inline-block;
            position: absolute;
            top: 0;
        }
        .dot-flashing::before {
            left: -12px;
            width: 8px;
            height: 8px;
            border-radius: 5px;
            background-color: #64748b;
            color: #64748b;
            animation: dotFlashing 1s infinite alternate;
            animation-delay: 0s;
        }
        .dot-flashing::after {
            left: 12px;
            width: 8px;
            height: 8px;
            border-radius: 5px;
            background-color: #64748b;
            color: #64748b;
            animation: dotFlashing 1s infinite alternate;
            animation-delay: 1s;
        }
        @keyframes dotFlashing {
            0% { background-color: #64748b; }
            50%, 100% { background-color: #cbd5e1; }
        }
        .screen-bg {
            background-color: #f8fafc; /* slate-50 */
            background-image: radial-gradient(#e2e8f0 1px, transparent 1px);
            background-size: 1.5rem 1.5rem;
        }
    </style>
</head>
<body class="flex items-center justify-center h-screen p-4 bg-slate-100">

    <div class="w-full max-w-5xl h-full flex flex-col bg-white shadow-2xl rounded-2xl border border-slate-200">
        <!-- ì´ˆê¸° í™”ë©´ -->
        <div id="initial-screen" class="flex flex-col items-center justify-center h-full p-8 text-center screen-bg rounded-2xl">
            <svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="text-indigo-500 mb-6 opacity-80"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
            <h1 class="text-3xl sm:text-4xl font-bold text-slate-900 mb-3 tracking-tight">ì¸ë¬¼ë°±ê³¼ LIVE</h1>
            <p class="text-slate-600 text-base sm:text-lg mb-8">ëŒ€í™”í•˜ê³  ì‹¶ì€ ì¸ë¬¼ì˜ ì´ë¦„ì„ ì…ë ¥í•˜ê³  ëŒ€í™”ë¥¼ ì‹œì‘í•˜ì„¸ìš”.</p>
            <div class="w-full max-w-md">
                <input type="text" id="characterInput" class="w-full text-base px-4 py-3 border border-slate-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 mb-4" placeholder="ì˜ˆ: ì„¸ì¢…ëŒ€ì™•, ì´ìˆœì‹ , ì•„ì¸ìŠˆíƒ€ì¸...">
                <button id="startButton" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">ì¸ë¬¼ ê²€ìƒ‰</button>
            </div>
        </div>
        
        <!-- ì¸ë¬¼ ì„ íƒ í™”ë©´ -->
        <div id="selection-screen" class="hidden flex flex-col items-center justify-center h-full p-4 sm:p-8 screen-bg rounded-2xl">
            <h2 class="text-3xl sm:text-4xl font-bold text-slate-900 mb-3 tracking-tight">ëŒ€í™”í•  ì¸ë¬¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”</h2>
            <p class="text-slate-600 text-base sm:text-lg mb-8">ì…ë ¥í•˜ì‹  ì´ë¦„ìœ¼ë¡œ ì—¬ëŸ¬ ì¸ë¬¼ì´ ê²€ìƒ‰ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
            <div id="character-selection-list" class="w-full max-w-3xl border border-slate-200 rounded-lg overflow-y-auto max-h-[50vh] sm:max-h-80 bg-white">
                <!-- í›„ë³´ ë¦¬ìŠ¤íŠ¸ê°€ ì—¬ê¸°ì— ì¶”ê°€ë©ë‹ˆë‹¤. -->
            </div>
             <button id="backButton" class="mt-8 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all duration-200 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 text-base">ë’¤ë¡œê°€ê¸°</button>
        </div>

        <!-- ì±„íŒ… í™”ë©´ -->
        <div id="chat-screen" class="hidden flex flex-col sm:flex-row h-full rounded-2xl overflow-hidden">
            <!-- ì™¼ìª½ ì¸ë¬¼ ì •ë³´ íŒ¨ë„ -->
            <div class="w-full sm:w-1/3 p-6 flex flex-col items-center justify-start border-b sm:border-b-0 sm:border-r border-slate-200 screen-bg">
                <div class="w-full text-center pt-4 sm:pt-0">
                    <img id="character-image" src="" alt="ì´ˆìƒí™”" class="hidden w-36 h-36 sm:w-48 sm:h-48 rounded-full object-cover border-4 border-white shadow-lg mb-5 bg-slate-200 mx-auto ring-4 ring-slate-200">
                    <h2 class="text-2xl sm:text-3xl font-bold text-slate-900 tracking-tight" id="character-name-display"></h2>
                    <a id="wikiLink" href="#" target="_blank" class="hidden mt-3 inline-flex items-center gap-2 bg-white hover:bg-slate-100 border border-slate-300 text-slate-700 font-semibold py-1 px-3 rounded-full text-xs transition-colors duration-200">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>
                        ìœ„í‚¤í”¼ë””ì•„ ë°”ë¡œê°€ê¸°
                    </a>
                    <p id="character-description" class="text-base text-slate-600 mt-3 max-h-56 sm:max-h-72 overflow-y-auto leading-relaxed"></p>
                </div>
            </div>
            
            <!-- ì˜¤ë¥¸ìª½ ì±„íŒ… íŒ¨ë„ -->
            <div class="w-full sm:w-2/3 flex flex-col h-full bg-white">
                <!-- í—¤ë” -->
                <div class="flex items-center justify-between p-3 border-b border-slate-200 bg-white">
                    <p class="text-sm text-slate-500 pl-2">â€» ë³¸ ëŒ€í™”ëŠ” AIê°€ ìƒì„±í•œ ê°€ìƒ ë‹µë³€ì…ë‹ˆë‹¤.</p>
                    <button id="restartButton" class="bg-white hover:bg-slate-100 border border-slate-300 text-slate-700 font-semibold py-2 px-4 rounded-lg text-sm transition-colors duration-200">ìƒˆ ëŒ€í™” ì‹œì‘</button>
                </div>
                
                <div id="chatbox" class="flex-1 p-4 sm:p-6 overflow-y-auto bg-slate-100"></div>

                <div class="p-4 border-t border-slate-200 bg-white/80 backdrop-blur-sm">
                    <div class="flex items-center space-x-3">
                        <input type="text" id="userInput" class="flex-1 w-full px-4 py-3 text-base border border-slate-300 rounded-full focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500" placeholder="ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”...">
                        <button id="sendButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-3 rounded-full shadow-md transition-all duration-200 transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-send"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const initialScreen = document.getElementById('initial-screen');
        const selectionScreen = document.getElementById('selection-screen');
        const chatScreen = document.getElementById('chat-screen');
        const characterInput = document.getElementById('characterInput');
        const startButton = document.getElementById('startButton');
        const backButton = document.getElementById('backButton');
        const characterSelectionList = document.getElementById('character-selection-list');
        const chatbox = document.getElementById('chatbox');
        const userInput = document.getElementById('userInput');
        const sendButton = document.getElementById('sendButton');
        const restartButton = document.getElementById('restartButton');
        const characterNameDisplay = document.getElementById('character-name-display');
        const characterImage = document.getElementById('character-image');
        const characterDescription = document.getElementById('character-description');
        const wikiLink = document.getElementById('wikiLink');

        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        
        const emojiPlaceholder = 'data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100%" height="100%" fill="%23e2e8f0"/><text x="50%" y="50%" dominant-baseline="central" text-anchor="middle" font-size="60">ğŸ˜Š</text></svg>';

        let chatHistory = [];
        let systemPrompt = "";
        let characterName = ""; // This will store the full original name for API calls

        const cleanName = (name) => {
            return name.split('(')[0].trim();
        };

        const cleanMarkdown = (text) => {
            if (!text) return '';
            // Removes markdown characters like *, **, #, etc.
            return text.replace(/([_*#`~])/g, '');
        };

        const fetchWithRetry = async (url, options, retries = 3, delay = 500) => {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return response;
                } catch (error) {
                    console.error(`Fetch attempt ${i + 1} for ${url} failed. Retrying in ${delay}ms...`, error);
                    if (i < retries - 1) {
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2; // Exponential backoff
                    } else {
                        throw error; // Rethrow the last error
                    }
                }
            }
        };


        window.addEventListener('load', async () => {
            const savedData = sessionStorage.getItem('chatData');
            if (savedData) {
                const { savedCharacterName, savedSystemPrompt, savedChatHistory } = JSON.parse(savedData);
                characterName = savedCharacterName;
                systemPrompt = savedSystemPrompt;
                chatHistory = savedChatHistory;
                
                initialScreen.classList.add('hidden');
                chatScreen.classList.remove('hidden');

                chatHistory.forEach(message => {
                    addMessageToChatbox(message.role === 'user' ? 'user' : 'bot', message.parts[0].text);
                });
                
                // Call fetchCharacterDetails but we don't need to await it here
                // because the system prompt is already saved.
                fetchCharacterDetails(characterName);
                
                autoScroll();
            }
        });

        const searchForCharacter = async () => {
            const query = characterInput.value.trim();
            if (!query) {
                alert('ì¸ë¬¼ì˜ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            const searchEndpoint = `https://ko.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(query)}&srlimit=5&srprop=snippet&format=json&origin=*`;
            try {
                const response = await fetchWithRetry(searchEndpoint);
                const data = await response.json();
                const searchResults = data.query.search;

                if (searchResults.length === 0) {
                    alert('í•´ë‹¹ ì¸ë¬¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰í•´ë³´ì„¸ìš”.');
                } else if (searchResults.length === 1 && cleanName(searchResults[0].title).toLowerCase() === query.toLowerCase()) {
                    initiateChat(searchResults[0].title);
                } else {
                    displayCharacterChoices(searchResults);
                }
            } catch (error) {
                console.error('Error searching Wikipedia:', error);
                alert('ì¸ë¬¼ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        };

        const displayCharacterChoices = (choices) => {
            characterSelectionList.innerHTML = '';
            initialScreen.classList.add('hidden');
            selectionScreen.classList.remove('hidden');

            choices.forEach(async choice => {
                const choiceElement = document.createElement('div');
                choiceElement.className = 'p-4 sm:p-5 hover:bg-slate-100 cursor-pointer border-b border-slate-200 last:border-b-0 text-left transition-colors duration-200 flex items-center gap-4';
                
                const img = document.createElement('img');
                img.className = 'w-16 h-16 rounded-full object-cover bg-slate-300 flex-shrink-0';
                
                img.src = emojiPlaceholder;
                img.alt = choice.title;
                img.onerror = () => { img.src = emojiPlaceholder; img.onerror = null; };

                const textWrapper = document.createElement('div');

                const title = document.createElement('h3');
                title.className = 'font-semibold text-base sm:text-lg text-slate-800';
                title.textContent = cleanName(choice.title);

                const description = document.createElement('p');
                description.className = 'text-sm text-slate-600 mt-1';
                
                let snippetText = choice.snippet.replace(/<[^>]*>/g, '').trim();
                const firstSentenceEnd = snippetText.indexOf('. ');
                if (firstSentenceEnd !== -1) {
                    const secondSentenceEnd = snippetText.indexOf('. ', firstSentenceEnd + 1);
                    if (secondSentenceEnd !== -1) {
                        snippetText = snippetText.substring(0, secondSentenceEnd + 1);
                    } else {
                        snippetText = snippetText.substring(0, firstSentenceEnd + 1);
                    }
                } else {
                    snippetText = snippetText.length > 120 ? snippetText.substring(0, 120) + '...' : snippetText;
                }
                description.textContent = snippetText;


                textWrapper.appendChild(title);
                textWrapper.appendChild(description);
                
                choiceElement.appendChild(img);
                choiceElement.appendChild(textWrapper);
                
                choiceElement.addEventListener('click', () => initiateChat(choice.title));
                characterSelectionList.appendChild(choiceElement);

                try {
                    const endpoint = `https://ko.wikipedia.org/w/api.php?action=query&format=json&prop=pageimages&pithumbsize=100&titles=${encodeURIComponent(choice.title)}&origin=*`;
                    const response = await fetchWithRetry(endpoint);
                    const data = await response.json();
                    const page = Object.values(data.query.pages)[0];
                    if (page.thumbnail) {
                        img.src = page.thumbnail.source;
                    }
                } catch (error) {
                    console.error(`Error fetching thumbnail for ${choice.title}:`, error);
                }
            });
        };

        const fetchCharacterDetails = async (originalName) => {
            const endpoint = `https://ko.wikipedia.org/w/api.php?action=query&format=json&prop=pageimages|extracts&pithumbsize=300&titles=${encodeURIComponent(originalName)}&exintro=true&explaintext=true&origin=*`;
            let pageExtract = 'ì´ ì¸ë¬¼ì— ëŒ€í•œ ê°„ëµí•œ ì†Œê°œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'; 

            try {
                characterNameDisplay.textContent = cleanName(originalName);
                characterDescription.textContent = 'ìš”ì•½ ì •ë³´ë¥¼ ìƒì„± ì¤‘ì…ë‹ˆë‹¤...';
                
                const wikiUrl = `https://ko.wikipedia.org/wiki/${encodeURIComponent(originalName)}`;
                wikiLink.href = wikiUrl;
                wikiLink.classList.remove('hidden');

                characterImage.src = emojiPlaceholder;
                characterImage.classList.remove('hidden');

                const response = await fetchWithRetry(endpoint);
                const data = await response.json();
                const page = Object.values(data.query.pages)[0];
                
                if (page.extract) {
                    pageExtract = page.extract;
                }

                if (page.thumbnail) {
                    characterImage.src = page.thumbnail.source;
                }

                try {
                    const summaryPrompt = `ë‹¤ìŒ í…ìŠ¤íŠ¸ë¥¼ í•™ìƒì´ ì´í•´í•˜ê¸° ì‰½ë„ë¡ ê°€ì¥ ì¤‘ìš”í•œ ë‚´ìš© ìœ„ì£¼ë¡œ ìŠ¤í¬ë¡¤ì´ ìƒê¸°ì§€ ì•Šì„ ì •ë„ì˜ ê°„ê²°í•œ í•œ ë¬¸ë‹¨ìœ¼ë¡œ ìš”ì•½í•´ì¤˜. ì ˆëŒ€ë¡œ ë§ˆí¬ë‹¤ìš´ ì„œì‹ì„ ì‚¬ìš©í•˜ì§€ ë§ˆ:\n\n${pageExtract}`;
                    const summaryPayload = { contents: [{ parts: [{ text: summaryPrompt }] }] };
                    
                    const summaryResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(summaryPayload)
                    });

                    if (summaryResponse.ok) {
                        const summaryResult = await summaryResponse.json();
                        if (summaryResult.candidates && summaryResult.candidates[0].content.parts[0].text) {
                             let summaryText = summaryResult.candidates[0].content.parts[0].text;
                             characterDescription.textContent = cleanMarkdown(summaryText);
                        }
                    } else {
                         const snippet = pageExtract.length > 150 ? pageExtract.substring(0, 150) + '...' : pageExtract;
                         characterDescription.textContent = snippet;
                    }
                } catch (summaryError) {
                     console.error('AI ìš”ì•½ ì¤‘ ì˜¤ë¥˜ ë°œìƒ, ì¼ë¶€ ì›ë¬¸ì„ í‘œì‹œí•©ë‹ˆë‹¤:', summaryError);
                     const snippet = pageExtract.length > 150 ? pageExtract.substring(0, 150) + '...' : pageExtract;
                     characterDescription.textContent = snippet;
                }

                return pageExtract; // Return the full text for system prompt

            } catch (error) {
                console.error('ì¸ë¬¼ ì •ë³´ ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
                characterDescription.textContent = 'ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
                return pageExtract;
            } finally {
                characterImage.onerror = () => {
                    characterImage.src = emojiPlaceholder;
                    characterImage.onerror = null;
                };
            }
        };

        const setupSystemPromptAndDetails = async (originalName) => {
            const pageExtract = await fetchCharacterDetails(originalName);
            const currentDate = new Date().toLocaleDateString('ko-KR');

            systemPrompt = `í˜„ì¬ ë‚ ì§œëŠ” ${currentDate}ì…ë‹ˆë‹¤. ë‹¹ì‹ ì˜ ì •ì²´ì„±ì€ '${originalName}'ì…ë‹ˆë‹¤. ë‹¹ì‹ ì˜ ëª¨ë“  ë‹µë³€ì€ ì•„ë˜ ì œê³µëœ ìµœì‹  ìœ„í‚¤í”¼ë””ì•„ ì •ë³´ë¥¼ ê°€ì¥ ì¤‘ìš”í•œ í•µì‹¬ ì°¸ê³  ìë£Œë¡œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤. ì´ ì •ë³´ì— ì—†ëŠ” ë‚´ìš©ì€ ë‹¹ì‹ ì˜ ê¸°ì¡´ ì§€ì‹ì„ í™œìš©í•˜ì—¬ ìì—°ìŠ¤ëŸ½ê²Œ ë‹µë³€í•˜ë˜, ìœ„í‚¤í”¼ë””ì•„ ë‚´ìš©ê³¼ ì¶©ëŒí•´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤.

--- ì œê³µëœ ìœ„í‚¤í”¼ë””ì•„ ì •ë³´ ---
${pageExtract}
--- ì •ë³´ ë ---

ì‚¬ìš©ìëŠ” ì—¬ëŸ¬ ë™ëª…ì´ì¸ ì¤‘ì—ì„œ ë‹¹ì‹ ì„ ì„ íƒí–ˆìœ¼ë¯€ë¡œ ë‹¤ë¥¸ ì¸ë¬¼ê³¼ í˜¼ë™í•˜ì§€ ë§ˆì„¸ìš”. ë‹¹ì‹ ì˜ ìƒì• , ì—…ì , ê°€ì¹˜ê´€ì— ëŒ€í•´ 1ì¸ì¹­ ì‹œì ìœ¼ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”. í•™ìƒì´ ì´í•´í•˜ê¸° ì‰½ë„ë¡ ì¹œì ˆí•˜ê²Œ ì„¤ëª…í•˜ë˜, ì—­ì‚¬ì  ì‚¬ì‹¤ì— ê¸°ë°˜í•´ì•¼ í•©ë‹ˆë‹¤. ë‹µë³€ì€ í•­ìƒ í•œêµ­ì–´ë¡œ, ê·¸ë¦¬ê³  ê°„ê²°í•˜ê²Œ 2~3ë¬¸ì¥ ë‚´ì™¸ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”. ì ˆëŒ€ë¡œ, ì–´ë– í•œ ê²½ìš°ì—ë„ ë‹µë³€ì— '**', '*', '#'ì™€ ê°™ì€ ë§ˆí¬ë‹¤ìš´ ì„œì‹ì„ ì‚¬ìš©í•´ì„œëŠ” ì•ˆë©ë‹ˆë‹¤. ë‹µë³€ì€ ë¬´ì¡°ê±´ ìˆœìˆ˜ í…ìŠ¤íŠ¸(Plain Text)ì—¬ì•¼ í•©ë‹ˆë‹¤.`;

            saveToSession(); // Re-save with the full prompt
        };

        const initiateChat = (originalName) => {
            characterName = originalName; 
            selectionScreen.classList.add('hidden');
            initialScreen.classList.add('hidden');
            chatScreen.classList.remove('hidden');
            
            chatbox.innerHTML = ''; 
            
            const displayName = cleanName(originalName);
            const firstMessageText = `ì•ˆë…•í•˜ì„¸ìš”, ì €ëŠ” ${displayName}ì…ë‹ˆë‹¤. ë¬´ì—‡ì´ ê¶ê¸ˆí•˜ì‹ ê°€ìš”?`;
            const firstMessage = { role: 'model', parts: [{ text: firstMessageText }] };
            chatHistory = [firstMessage];
            
            addMessageToChatbox('bot', firstMessageText);
            
            // Set up details and the full system prompt in the background
            setupSystemPromptAndDetails(originalName);
            
            saveToSession(); // Save initial state
        };

        const sendMessage = async () => {
            const messageText = userInput.value.trim();
            if (!messageText) return;
            addMessageToChatbox('user', messageText);
            userInput.value = '';
            chatHistory.push({ role: 'user', parts: [{ text: messageText }] });
            saveToSession();
            addLoadingIndicator();
            try {
                const response = await getGeminiResponse();
                removeLoadingIndicator();
                let botMessageText = response.candidates[0].content.parts[0].text;
                botMessageText = cleanMarkdown(botMessageText); // Clean the response
                addMessageToChatbox('bot', botMessageText);
                chatHistory.push({ role: 'model', parts: [{ text: botMessageText }] });
                saveToSession();
            } catch (error) {
                console.error('API í˜¸ì¶œ ì˜¤ë¥˜:', error);
                removeLoadingIndicator();
                addMessageToChatbox('bot', 'ì£„ì†¡í•©ë‹ˆë‹¤. ë‹µë³€ì„ ìƒì„±í•˜ëŠ” ì¤‘ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        };
        
        const getGeminiResponse = async (retries = 3, delay = 1000) => {
             const payload = { contents: chatHistory, systemInstruction: { parts: [{ text: systemPrompt }] } };
             for (let i = 0; i< retries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return await response.json();
                } catch (error) {
                    console.error(`Attempt ${i + 1} failed. Retrying in ${delay}ms...`, error);
                    if (i < retries - 1) {
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2;
                    } else throw error;
                }
            }
        };

        const addMessageToChatbox = (sender, message) => {
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `flex mb-4 ${sender === 'user' ? 'justify-end' : 'justify-start'}`;
            const messageBubble = document.createElement('div');
            messageBubble.className = `message-bubble rounded-xl py-2 px-4 shadow-sm ${sender === 'user' ? 'user text-white' : 'bot text-slate-800'}`;
            messageBubble.textContent = message;
            messageWrapper.appendChild(messageBubble);
            chatbox.appendChild(messageWrapper);
            autoScroll();
        };
        
        const addLoadingIndicator = () => {
            const loadingWrapper = document.createElement('div');
            loadingWrapper.id = 'loading-indicator';
            loadingWrapper.className = 'flex justify-start mb-4';
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble bot rounded-xl p-4 shadow-sm flex items-center justify-center';
            const dots = document.createElement('div');
            dots.className = 'dot-flashing';
            bubble.appendChild(dots);
            loadingWrapper.appendChild(bubble);
            chatbox.appendChild(loadingWrapper);
            autoScroll();
        };

        const removeLoadingIndicator = () => {
            const indicator = document.getElementById('loading-indicator');
            if (indicator) indicator.remove();
        };
        
        const autoScroll = () => { chatbox.scrollTop = chatbox.scrollHeight; };
        
        const restartChat = () => {
            sessionStorage.removeItem('chatData');
            chatHistory = [];
            systemPrompt = "";
            characterName = "";
            chatbox.innerHTML = '';
            characterInput.value = '';
            characterImage.classList.add('hidden');
            characterImage.src = '';
            wikiLink.classList.add('hidden');
            selectionScreen.classList.add('hidden');
            chatScreen.classList.add('hidden');
            initialScreen.classList.remove('hidden');
        };

        const saveToSession = () => {
            const dataToSave = {
                savedCharacterName: characterName,
                savedSystemPrompt: systemPrompt,
                savedChatHistory: chatHistory
            };
            sessionStorage.setItem('chatData', JSON.stringify(dataToSave));
        };
        
        const goBackToInitial = () => {
            selectionScreen.classList.add('hidden');
            initialScreen.classList.remove('hidden');
        }

        startButton.addEventListener('click', searchForCharacter);
        sendButton.addEventListener('click', sendMessage);
        restartButton.addEventListener('click', restartChat);
        backButton.addEventListener('click', goBackToInitial);
        userInput.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); sendMessage(); } });
        characterInput.addEventListener('keydown', e => { if (e.key === 'Enter') searchForCharacter(); });
    </script>
</body>
</html>

